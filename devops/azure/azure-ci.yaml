# Azure DevOps Pipeline for TaskForge .NET 8
# Build, test and publish .NET 8 application
# https://docs.microsoft.com/azure/devops/pipelines/languages/dotnet-core

trigger:
  branches:
    include:
    - master
    - dev
    - feature/*
  paths:
    exclude:
    - README.md
    - docs/*
    - design/*

pr:
  branches:
    include:
    - master
    - dev
    - feature/*

pool:
  vmImage: 'windows-latest'

variables:
  solution: '**/TaskForge.sln'
  buildConfiguration: 'Release'
  dotNetVersion: '8.0.411'
  
  # Code coverage variables
  codeCoverageTool: 'Cobertura'
  summaryFileLocation: '$(System.DefaultWorkingDirectory)/**/coverage.cobertura.xml'
  # Minimum code coverage percentage required per service
  minimumCodeCoverageAPI: 80
  minimumCodeCoverageEventProcessor: 0
  minimumCodeCoverageMessageConsumer: 0
  minimumCodeCoverageCommon: 75

stages:
- stage: BuildAndTest
  displayName: 'Build and Test Services'
  jobs:
  - job: BuildCommonProjects
    displayName: 'Build Common Projects (Domain, Application, Persistence)'
    steps:
    - task: UseDotNet@2
      displayName: 'Use .NET SDK $(dotNetVersion)'
      inputs:
        packageType: 'sdk'
        version: '$(dotNetVersion)'
        installationPath: '$(Agent.ToolsDirectory)/dotnet'

    - task: DotNetCoreCLI@2
      displayName: 'Restore NuGet packages'
      inputs:
        command: 'restore'
        projects: |
          src/TaskForge.Domain/TaskForge.Domain.csproj
          src/TaskForge.Application/TaskForge.Application.csproj
          src/TaskForge.Persistence/TaskForge.Persistence.csproj
          src/TaskForge.StartupTasks/TaskForge.StartupTasks.csproj
        feedsToUse: 'select'
        verbosityRestore: 'Minimal'

    - task: DotNetCoreCLI@2
      displayName: 'Build Common Projects'
      inputs:
        command: 'build'
        projects: |
          src/TaskForge.Domain/TaskForge.Domain.csproj
          src/TaskForge.Application/TaskForge.Application.csproj
          src/TaskForge.Persistence/TaskForge.Persistence.csproj
          src/TaskForge.StartupTasks/TaskForge.StartupTasks.csproj
        arguments: '--configuration $(buildConfiguration) --no-restore'
        verbosity: 'minimal'
      continueOnError: false

  - job: BuildAndTestAPI
    displayName: 'Build and Test API'
    dependsOn: BuildCommonProjects
    steps:
    - task: UseDotNet@2
      displayName: 'Use .NET SDK $(dotNetVersion)'
      inputs:
        packageType: 'sdk'
        version: '$(dotNetVersion)'
        installationPath: '$(Agent.ToolsDirectory)/dotnet'

    - task: DotNetCoreCLI@2
      displayName: 'Restore API and Tests'
      inputs:
        command: 'restore'
        projects: |
          src/TaskForge.API/TaskForge.API.csproj
          tests/Tests.TaskForge.API/Tests.TaskForge.API.csproj
          tests/IntegratonTests.TaskForge.API/IntegratonTests.TaskForge.API.csproj
        feedsToUse: 'select'
        verbosityRestore: 'Minimal'

    - task: DotNetCoreCLI@2
      displayName: 'Build API'
      inputs:
        command: 'build'
        projects: 'src/TaskForge.API/TaskForge.API.csproj'
        arguments: '--configuration $(buildConfiguration) --no-restore'
        verbosity: 'minimal'
      continueOnError: false

    - task: DotNetCoreCLI@2
      displayName: 'Build API Test Projects'
      inputs:
        command: 'build'
        projects: |
          tests/Tests.TaskForge.API/Tests.TaskForge.API.csproj
          tests/IntegratonTests.TaskForge.API/IntegratonTests.TaskForge.API.csproj
        arguments: '--configuration $(buildConfiguration) --no-restore'
        verbosity: 'minimal'
      continueOnError: false

    - task: PowerShell@2
      displayName: 'Verify API Build Success on PR'
      condition: eq(variables['Build.Reason'], 'PullRequest')
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "✅ API Build completed successfully!"

    - task: DotNetCoreCLI@2
      displayName: 'Run API Unit Tests'
      inputs:
        command: 'test'
        projects: 'tests/Tests.TaskForge.API/Tests.TaskForge.API.csproj'
        arguments: '--configuration $(buildConfiguration) --no-build --nologo --collect:"XPlat Code Coverage" --settings:$(System.DefaultWorkingDirectory)/tests/coverlet.runsettings --logger "console;verbosity=normal" --blame'
        publishTestResults: true
        testRunTitle: 'API Unit Tests - $(Build.SourceBranchName)'
      continueOnError: false

    - task: DotNetCoreCLI@2
      displayName: 'Run API Integration Tests'
      inputs:
        command: 'test'
        projects: 'tests/IntegratonTests.TaskForge.API/IntegratonTests.TaskForge.API.csproj'
        arguments: '--configuration $(buildConfiguration) --no-build --nologo --collect:"XPlat Code Coverage" --settings:$(System.DefaultWorkingDirectory)/tests/coverlet.runsettings --logger "console;verbosity=normal" --blame'
        publishTestResults: true
        testRunTitle: 'API Integration Tests - $(Build.SourceBranchName)'
      continueOnError: false

    # - task: DotNetCoreCLI@2
    #   displayName: 'Publish API'
    #   condition: ne(variables['Build.Reason'], 'PullRequest')
    #   inputs:
    #     command: 'publish'
    #     projects: 'src/TaskForge.API/TaskForge.API.csproj'
    #     arguments: '--configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)/api --no-restore'
    #     zipAfterPublish: false
    #
    # - task: PowerShell@2
    #   displayName: 'Clean conflicting appsettings files from API publish'
    #   condition: ne(variables['Build.Reason'], 'PullRequest')
    #   inputs:
    #     targetType: 'inline'
    #     script: |
    #       # Remove appsettings files from EventProcessor and MessageConsumer if they were copied
    #       $apiDir = "$(Build.ArtifactStagingDirectory)/api"
    #       if (Test-Path $apiDir) {
    #         Get-ChildItem -Path $apiDir -Filter "appsettings*.json" -Recurse | 
    #           Where-Object { $_.DirectoryName -notlike "*TaskForge.API*" } | 
    #           Remove-Item -Force
    #         Write-Host "Cleaned conflicting appsettings files"
    #       }
    
    # - task: PowerShell@2
    #   displayName: 'Create ZIP for API'
    #   condition: ne(variables['Build.Reason'], 'PullRequest')
    #   inputs:
    #     targetType: 'inline'
    #     script: |
    #       Compress-Archive -Path "$(Build.ArtifactStagingDirectory)/api/*" -DestinationPath "$(Build.ArtifactStagingDirectory)/api.zip" -Force

  - job: BuildAndTestEventProcessor
    displayName: 'Build and Test EventProcessor'
    dependsOn: BuildCommonProjects
    steps:
    - task: UseDotNet@2
      displayName: 'Use .NET SDK $(dotNetVersion)'
      inputs:
        packageType: 'sdk'
        version: '$(dotNetVersion)'
        installationPath: '$(Agent.ToolsDirectory)/dotnet'

    - task: DotNetCoreCLI@2
      displayName: 'Restore EventProcessor and Tests'
      inputs:
        command: 'restore'
        projects: |
          src/TaskForge.EventProcessor/TaskForge.EventProcessor.csproj
          tests/Tests.TaskForge.EventProcessor/Tests.TaskForge.EventProcessor.csproj
          tests/IntegratonTests.TaskForge.EventProcessor/IntegratonTests.TaskForge.EventProcessor.csproj
        feedsToUse: 'select'
        verbosityRestore: 'Minimal'

    - task: DotNetCoreCLI@2
      displayName: 'Build EventProcessor'
      inputs:
        command: 'build'
        projects: 'src/TaskForge.EventProcessor/TaskForge.EventProcessor.csproj'
        arguments: '--configuration $(buildConfiguration) --no-restore'
        verbosity: 'minimal'
      continueOnError: false

    - task: DotNetCoreCLI@2
      displayName: 'Build EventProcessor Test Projects'
      inputs:
        command: 'build'
        projects: |
          tests/Tests.TaskForge.EventProcessor/Tests.TaskForge.EventProcessor.csproj
          tests/IntegratonTests.TaskForge.EventProcessor/IntegratonTests.TaskForge.EventProcessor.csproj
        arguments: '--configuration $(buildConfiguration) --no-restore'
        verbosity: 'minimal'
      continueOnError: false

    - task: PowerShell@2
      displayName: 'Verify EventProcessor Build Success on PR'
      condition: eq(variables['Build.Reason'], 'PullRequest')
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "✅ EventProcessor Build completed successfully!"

    - task: DotNetCoreCLI@2
      displayName: 'Run EventProcessor Unit Tests'
      inputs:
        command: 'test'
        projects: 'tests/Tests.TaskForge.EventProcessor/Tests.TaskForge.EventProcessor.csproj'
        arguments: '--configuration $(buildConfiguration) --no-build --nologo --collect:"XPlat Code Coverage" --settings:$(System.DefaultWorkingDirectory)/tests/coverlet.runsettings --logger "console;verbosity=normal" --blame'
        publishTestResults: true
        testRunTitle: 'EventProcessor Unit Tests - $(Build.SourceBranchName)'
      continueOnError: false

    - task: DotNetCoreCLI@2
      displayName: 'Run EventProcessor Integration Tests'
      inputs:
        command: 'test'
        projects: 'tests/IntegratonTests.TaskForge.EventProcessor/IntegratonTests.TaskForge.EventProcessor.csproj'
        arguments: '--configuration $(buildConfiguration) --no-build --nologo --collect:"XPlat Code Coverage" --settings:$(System.DefaultWorkingDirectory)/tests/coverlet.runsettings --logger "console;verbosity=normal" --blame'
        publishTestResults: true
        testRunTitle: 'EventProcessor Integration Tests - $(Build.SourceBranchName)'
      continueOnError: false

    # - task: DotNetCoreCLI@2
    #   displayName: 'Publish EventProcessor'
    #   condition: ne(variables['Build.Reason'], 'PullRequest')
    #   inputs:
    #     command: 'publish'
    #     projects: 'src/TaskForge.EventProcessor/TaskForge.EventProcessor.csproj'
    #     arguments: '--configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)/eventprocessor --no-restore'
    #     zipAfterPublish: false
    
    # - task: PowerShell@2
    #   displayName: 'Create ZIP for EventProcessor'
    #   condition: ne(variables['Build.Reason'], 'PullRequest')
    #   inputs:
    #     targetType: 'inline'
    #     script: |
    #       Compress-Archive -Path "$(Build.ArtifactStagingDirectory)/eventprocessor/*" -DestinationPath "$(Build.ArtifactStagingDirectory)/eventprocessor.zip" -Force

  - job: BuildAndTestMessageConsumer
    displayName: 'Build and Test MessageConsumer'
    dependsOn: BuildCommonProjects
    steps:
    - task: UseDotNet@2
      displayName: 'Use .NET SDK $(dotNetVersion)'
      inputs:
        packageType: 'sdk'
        version: '$(dotNetVersion)'
        installationPath: '$(Agent.ToolsDirectory)/dotnet'

    - task: DotNetCoreCLI@2
      displayName: 'Restore MessageConsumer and Tests'
      inputs:
        command: 'restore'
        projects: |
          src/TaskForge.MessageConsumer/TaskForge.MessageConsumer.csproj
          tests/Tests.TaskForge.MessageConsumer/Tests.TaskForge.MessageConsumer.csproj
          tests/IntegratonTests.TaskForge.MessageConsumer/IntegratonTests.TaskForge.MessageConsumer.csproj
        feedsToUse: 'select'
        verbosityRestore: 'Minimal'

    - task: DotNetCoreCLI@2
      displayName: 'Build MessageConsumer'
      inputs:
        command: 'build'
        projects: 'src/TaskForge.MessageConsumer/TaskForge.MessageConsumer.csproj'
        arguments: '--configuration $(buildConfiguration) --no-restore'
        verbosity: 'minimal'
      continueOnError: false

    - task: DotNetCoreCLI@2
      displayName: 'Build MessageConsumer Test Projects'
      inputs:
        command: 'build'
        projects: |
          tests/Tests.TaskForge.MessageConsumer/Tests.TaskForge.MessageConsumer.csproj
          tests/IntegratonTests.TaskForge.MessageConsumer/IntegratonTests.TaskForge.MessageConsumer.csproj
        arguments: '--configuration $(buildConfiguration) --no-restore'
        verbosity: 'minimal'
      continueOnError: false

    - task: PowerShell@2
      displayName: 'Verify MessageConsumer Build Success on PR'
      condition: eq(variables['Build.Reason'], 'PullRequest')
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "✅ MessageConsumer Build completed successfully!"

    - task: DotNetCoreCLI@2
      displayName: 'Run MessageConsumer Unit Tests'
      inputs:
        command: 'test'
        projects: 'tests/Tests.TaskForge.MessageConsumer/Tests.TaskForge.MessageConsumer.csproj'
        arguments: '--configuration $(buildConfiguration) --no-build --nologo --collect:"XPlat Code Coverage" --settings:$(System.DefaultWorkingDirectory)/tests/coverlet.runsettings --logger "console;verbosity=normal" --blame'
        publishTestResults: true
        testRunTitle: 'MessageConsumer Unit Tests - $(Build.SourceBranchName)'
      continueOnError: false

    - task: DotNetCoreCLI@2
      displayName: 'Run MessageConsumer Integration Tests'
      inputs:
        command: 'test'
        projects: 'tests/IntegratonTests.TaskForge.MessageConsumer/IntegratonTests.TaskForge.MessageConsumer.csproj'
        arguments: '--configuration $(buildConfiguration) --no-build --nologo --collect:"XPlat Code Coverage" --settings:$(System.DefaultWorkingDirectory)/tests/coverlet.runsettings --logger "console;verbosity=normal" --blame'
        publishTestResults: true
        testRunTitle: 'MessageConsumer Integration Tests - $(Build.SourceBranchName)'
      continueOnError: false

    # - task: DotNetCoreCLI@2
    #   displayName: 'Publish MessageConsumer'
    #   condition: ne(variables['Build.Reason'], 'PullRequest')
    #   inputs:
    #     command: 'publish'
    #     projects: 'src/TaskForge.MessageConsumer/TaskForge.MessageConsumer.csproj'
    #     arguments: '--configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)/messageconsumer --no-restore'
    #     zipAfterPublish: false
    
    # - task: PowerShell@2
    #   displayName: 'Create ZIP for MessageConsumer'
    #   condition: ne(variables['Build.Reason'], 'PullRequest')
    #   inputs:
    #     targetType: 'inline'
    #     script: |
    #       Compress-Archive -Path "$(Build.ArtifactStagingDirectory)/messageconsumer/*" -DestinationPath "$(Build.ArtifactStagingDirectory)/messageconsumer.zip" -Force

  - job: RunCommonTests
    displayName: 'Run Common Tests (Application, Domain, Persistence)'
    dependsOn: BuildCommonProjects
    steps:
    - task: UseDotNet@2
      displayName: 'Use .NET SDK $(dotNetVersion)'
      inputs:
        packageType: 'sdk'
        version: '$(dotNetVersion)'
        installationPath: '$(Agent.ToolsDirectory)/dotnet'

    - task: DotNetCoreCLI@2
      displayName: 'Restore Common Test Projects'
      inputs:
        command: 'restore'
        projects: |
          tests/Tests.TaskForge.Application/Tests.TaskForge.Application.csproj
          tests/Tests.TaskForge.Domain/Tests.TaskForge.Domain.csproj
          tests/Tests.TaskForge.Persistence/Tests.TaskForge.Persistence.csproj
          tests/IntegratonTests.TaskForge.Application/IntegratonTests.TaskForge.Application.csproj
          tests/IntegratonTests.TaskForge.Persistence/IntegratonTests.TaskForge.Persistence.csproj
        feedsToUse: 'select'
        verbosityRestore: 'Minimal'

    - task: DotNetCoreCLI@2
      displayName: 'Build Common Test Projects'
      inputs:
        command: 'build'
        projects: |
          tests/Tests.TaskForge.Application/Tests.TaskForge.Application.csproj
          tests/Tests.TaskForge.Domain/Tests.TaskForge.Domain.csproj
          tests/Tests.TaskForge.Persistence/Tests.TaskForge.Persistence.csproj
          tests/IntegratonTests.TaskForge.Application/IntegratonTests.TaskForge.Application.csproj
          tests/IntegratonTests.TaskForge.Persistence/IntegratonTests.TaskForge.Persistence.csproj
        arguments: '--configuration $(buildConfiguration) --no-restore'
        verbosity: 'minimal'
      continueOnError: false

    - task: DotNetCoreCLI@2
      displayName: 'Run Common Unit Tests'
      inputs:
        command: 'test'
        projects: |
          tests/Tests.TaskForge.Application/Tests.TaskForge.Application.csproj
          tests/Tests.TaskForge.Domain/Tests.TaskForge.Domain.csproj
          tests/Tests.TaskForge.Persistence/Tests.TaskForge.Persistence.csproj
        arguments: '--configuration $(buildConfiguration) --no-build --nologo --collect:"XPlat Code Coverage" --settings:$(System.DefaultWorkingDirectory)/tests/coverlet.runsettings --logger "console;verbosity=normal" --blame'
        publishTestResults: true
        testRunTitle: 'Common Unit Tests - $(Build.SourceBranchName)'
      continueOnError: false

    - task: DotNetCoreCLI@2
      displayName: 'Run Common Integration Tests'
      inputs:
        command: 'test'
        projects: |
          tests/IntegratonTests.TaskForge.Application/IntegratonTests.TaskForge.Application.csproj
          tests/IntegratonTests.TaskForge.Persistence/IntegratonTests.TaskForge.Persistence.csproj
        arguments: '--configuration $(buildConfiguration) --no-build --nologo --collect:"XPlat Code Coverage" --settings:$(System.DefaultWorkingDirectory)/tests/coverlet.runsettings --logger "console;verbosity=normal" --blame'
        publishTestResults: true
        testRunTitle: 'Common Integration Tests - $(Build.SourceBranchName)'
      continueOnError: false

  - job: CheckCodeCoverage
    displayName: 'Check Code Coverage Threshold'
    dependsOn:
    - BuildAndTestAPI
    - BuildAndTestEventProcessor
    - BuildAndTestMessageConsumer
    - RunCommonTests
    condition: succeeded()
    steps:
    - task: PowerShell@2
      displayName: 'Check Code Coverage Threshold'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "================================================"
          Write-Host "Code Coverage Check (Per Service)"
          Write-Host "================================================"
          
          $coverageFiles = Get-ChildItem -Path "$(Agent.TempDirectory)/TestResults" -Recurse -Filter "coverage.cobertura.xml" -ErrorAction SilentlyContinue
          
          if (-not $coverageFiles) {
            Write-Warning "⚠️ No coverage files found. Tests may not have generated coverage data."
            Write-Host "This could happen if tests failed or coverage collection is disabled."
            Write-Host "Continuing without coverage validation..."
            exit 0
          }
          
          Write-Host "Found $($coverageFiles.Count) coverage file(s)"
          Write-Host ""
          
          # Group coverage files by service
          $serviceCoverage = @{
            "API" = @{ Files = @(); Lines = 0; Covered = 0; Threshold = [int]$(minimumCodeCoverageAPI) }
            "EventProcessor" = @{ Files = @(); Lines = 0; Covered = 0; Threshold = [int]$(minimumCodeCoverageEventProcessor) }
            "MessageConsumer" = @{ Files = @(); Lines = 0; Covered = 0; Threshold = [int]$(minimumCodeCoverageMessageConsumer) }
            "Common" = @{ Files = @(); Lines = 0; Covered = 0; Threshold = [int]$(minimumCodeCoverageCommon) }
          }
          
          # Categorize files by path
          foreach ($file in $coverageFiles) {
            $filePath = $file.FullName.ToLower()
            if ($filePath -like "*api*" -and $filePath -notlike "*eventprocessor*" -and $filePath -notlike "*messageconsumer*") {
              $serviceCoverage["API"].Files += $file
            } elseif ($filePath -like "*eventprocessor*") {
              $serviceCoverage["EventProcessor"].Files += $file
            } elseif ($filePath -like "*messageconsumer*") {
              $serviceCoverage["MessageConsumer"].Files += $file
            } else {
              $serviceCoverage["Common"].Files += $file
            }
          }
          
          $allPassed = $true
          
          # Check coverage for each service
          foreach ($service in $serviceCoverage.Keys) {
            $serviceData = $serviceCoverage[$service]
            
            # Skip check if threshold is 0 (no requirement)
            if ($serviceData.Threshold -eq 0) {
              if ($serviceData.Files.Count -eq 0) {
                Write-Host "ℹ️ No coverage requirement for $service service (threshold: 0%)"
              } else {
                Write-Host "ℹ️ Coverage check skipped for $service service (threshold: 0% - no requirement)"
              }
              Write-Host ""
              continue
            }
            
            if ($serviceData.Files.Count -eq 0) {
              Write-Host "⚠️ No coverage files found for $service service"
              Write-Host ""
              continue
            }
            
            Write-Host "----------------------------------------"
            Write-Host "Service: $service"
            Write-Host "Required Coverage: $($serviceData.Threshold)%"
            Write-Host "Coverage Files: $($serviceData.Files.Count)"
            Write-Host ""
            
            $serviceLines = 0
            $serviceCovered = 0
            
            foreach ($file in $serviceData.Files) {
              try {
                [xml]$coverageXml = Get-Content $file.FullName -ErrorAction Stop
                
                if ($coverageXml.coverage) {
                  $linesValid = [int]$coverageXml.coverage.'lines-valid'
                  $linesCovered = [int]$coverageXml.coverage.'lines-covered'
                  
                  if ($linesValid -gt 0) {
                    $serviceLines += $linesValid
                    $serviceCovered += $linesCovered
                    
                    $lineRate = ($linesCovered / $linesValid) * 100
                    Write-Host "  File: $($file.Name) - $linesCovered/$linesValid ($([math]::Round($lineRate, 2))%)"
                  }
                }
              } catch {
                Write-Warning "  Failed to parse coverage file $($file.Name): $_"
              }
            }
            
            if ($serviceLines -gt 0) {
              $serviceCoveragePercent = ($serviceCovered / $serviceLines) * 100
              $serviceCoveragePercent = [math]::Round($serviceCoveragePercent, 2)
              
              Write-Host ""
              Write-Host "  Total Coverage: $serviceCoveragePercent% ($serviceCovered/$serviceLines lines)"
              Write-Host "  Required: $($serviceData.Threshold)%"
              
              if ($serviceCoveragePercent -lt $serviceData.Threshold) {
                $allPassed = $false
                Write-Host ""
                Write-Error "  ❌ FAILED: Coverage $serviceCoveragePercent% is below required $($serviceData.Threshold)%"
                Write-Error "  Difference: $([math]::Round($serviceData.Threshold - $serviceCoveragePercent, 2))%"
              } else {
                Write-Host ""
                Write-Host "  ✅ PASSED: Coverage meets requirement"
              }
            } else {
              Write-Warning "  ⚠️ Could not calculate coverage for $service service"
            }
            
            Write-Host ""
          }
          
          Write-Host "================================================"
          
          if (-not $allPassed) {
            Write-Error ""
            Write-Error "❌ CODE COVERAGE CHECK FAILED!"
            Write-Error "One or more services do not meet the minimum coverage requirement."
            Write-Error "Please add more unit tests to improve code coverage."
            Write-Error "PR cannot be merged until all coverage requirements are met."
            Write-Error ""
            exit 1
          } else {
            Write-Host ""
            Write-Host "✅ CODE COVERAGE CHECK PASSED"
            Write-Host "All services meet their minimum coverage requirements."
            Write-Host ""
          }
          
          Write-Host "================================================"

    - task: PublishCodeCoverageResults@1
      displayName: 'Publish Code Coverage'
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: '$(Agent.TempDirectory)/TestResults/**/coverage.cobertura.xml'
        reportDirectory: '$(Agent.TempDirectory)/TestResults/**/coverage'
        failIfCoverageEmpty: false

  - job: PublishArtifacts
    displayName: 'Publish Build Artifacts'
    dependsOn:
    - BuildAndTestAPI
    - BuildAndTestEventProcessor
    - BuildAndTestMessageConsumer
    condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))
    steps:
    - task: PublishBuildArtifacts@1
      displayName: 'Publish All Artifacts'
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)'
        artifactName: 'drop'
        publishLocation: 'Container'

- stage: Docker
  displayName: 'Build Docker Images'
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
  jobs:
  - job: BuildDockerImages
    displayName: 'Build Docker Images'
    steps:
    - task: Docker@2
      displayName: 'Build API Docker Image'
      inputs:
        command: 'build'
        repository: 'taskforge-api'
        dockerfile: 'src/TaskForge.API/Dockerfile'
        buildContext: '$(System.DefaultWorkingDirectory)'
        tags: |
          $(Build.BuildId)
          latest

    - task: Docker@2
      displayName: 'Build EventProcessor Docker Image'
      inputs:
        command: 'build'
        repository: 'taskforge-eventprocessor'
        dockerfile: 'src/TaskForge.EventProcessor/Dockerfile'
        buildContext: '$(System.DefaultWorkingDirectory)'
        tags: |
          $(Build.BuildId)
          latest
