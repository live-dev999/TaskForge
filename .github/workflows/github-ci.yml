name: Build and Test

on:
  push:
    branches:
    - master
    - dev
      - feature/*
    paths-ignore:
      - 'README.md'
      - 'docs/**'
      - 'design/**'
  pull_request:
    branches:
    - master
    - dev
      - feature/*

permissions:
  contents: read
  checks: write
  pull-requests: write

env:
  SOLUTION: '**/TaskForge.sln'
  BUILD_CONFIGURATION: 'Release'
  DOTNET_VERSION: '8.0.411'
  # Code coverage thresholds
  MIN_COVERAGE_API: 18
  MIN_COVERAGE_EVENTPROCESSOR: 0
  MIN_COVERAGE_MESSAGECONSUMER: 0
  MIN_COVERAGE_COMMON: 40

jobs:
  build-common-projects:
    name: 'Build Common Projects (Domain, Application, Persistence)'
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET SDK ${{ env.DOTNET_VERSION }}
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Restore NuGet packages
      run: dotnet restore --verbosity minimal
      working-directory: src/TaskForge.Domain

    - name: Restore Application packages
      run: dotnet restore --verbosity minimal
      working-directory: src/TaskForge.Application

    - name: Restore Persistence packages
      run: dotnet restore --verbosity minimal
      working-directory: src/TaskForge.Persistence

    - name: Restore StartupTasks packages
      run: dotnet restore --verbosity minimal
      working-directory: src/TaskForge.StartupTasks

    - name: Build Common Projects
      run: |
        dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal
      working-directory: src/TaskForge.Domain

    - name: Build Application
      run: dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal
      working-directory: src/TaskForge.Application

    - name: Build Persistence
      run: dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal
      working-directory: src/TaskForge.Persistence

    - name: Build StartupTasks
      run: dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal
      working-directory: src/TaskForge.StartupTasks

  build-and-test-api:
    name: 'Build and Test API'
    needs: build-common-projects
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET SDK ${{ env.DOTNET_VERSION }}
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Restore API and Tests
      run: |
        dotnet restore --verbosity minimal src/TaskForge.API/TaskForge.API.csproj
        dotnet restore --verbosity minimal tests/Tests.TaskForge.API/Tests.TaskForge.API.csproj
        dotnet restore --verbosity minimal tests/IntegratonTests.TaskForge.API/IntegratonTests.TaskForge.API.csproj

    - name: Build API
      run: dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal
      working-directory: src/TaskForge.API

    - name: Build API Test Projects
      run: |
        dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal tests/Tests.TaskForge.API/Tests.TaskForge.API.csproj
        dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal tests/IntegratonTests.TaskForge.API/IntegratonTests.TaskForge.API.csproj

    - name: Verify API Build Success on PR
      if: github.event_name == 'pull_request'
      run: echo "✅ API Build completed successfully!"

    - name: Copy coverlet.runsettings to test projects
      run: |
        cp tests/coverlet.runsettings tests/Tests.TaskForge.API/coverlet.runsettings
        cp tests/coverlet.runsettings tests/IntegratonTests.TaskForge.API/coverlet.runsettings

    - name: Run API Unit Tests
      run: |
        dotnet test \
          --configuration ${{ env.BUILD_CONFIGURATION }} \
          --no-build \
          --nologo \
          --collect:"XPlat Code Coverage" \
          --settings coverlet.runsettings \
          --logger "trx;LogFileName=api-unit-tests.trx" \
          --logger "console;verbosity=normal" \
          --blame \
          /p:CollectCoverage=true \
          /p:CoverletOutput=./TestResults/ \
          /p:CoverletOutputFormat=lcov \
          Tests.TaskForge.API.csproj
      working-directory: tests/Tests.TaskForge.API

    - name: Run API Integration Tests
      run: |
        dotnet test \
          --configuration ${{ env.BUILD_CONFIGURATION }} \
          --no-build \
          --nologo \
          --collect:"XPlat Code Coverage" \
          --settings coverlet.runsettings \
          --logger "trx;LogFileName=api-integration-tests.trx" \
          --logger "console;verbosity=normal" \
          --blame \
          /p:CollectCoverage=true \
          /p:CoverletOutput=./TestResults/ \
          /p:CoverletOutputFormat=lcov \
          /p:MergeWith=./TestResults/coverage.info \
          IntegratonTests.TaskForge.API.csproj
      working-directory: tests/IntegratonTests.TaskForge.API

    - name: Publish Test Results
      uses: EnricoMi/publish-unit-test-result-action@v2
      if: always()
      with:
        files: '**/TestResults/**/*.trx'
        check_name: 'API Test Results'
        fail_on: 'errors'

    - name: Upload Code Coverage
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: api-coverage
        path: '**/TestResults/**/coverage.cobertura.xml'
        retention-days: 7

    - name: Upload LCOV Coverage for Coveralls
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: api-coverage-lcov
        path: '**/TestResults/**/coverage.info'
        retention-days: 7
        if-no-files-found: ignore

  build-and-test-eventprocessor:
    name: 'Build and Test EventProcessor'
    needs: build-common-projects
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET SDK ${{ env.DOTNET_VERSION }}
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Restore EventProcessor and Tests
      run: |
        dotnet restore --verbosity minimal src/TaskForge.EventProcessor/TaskForge.EventProcessor.csproj
        dotnet restore --verbosity minimal tests/Tests.TaskForge.EventProcessor/Tests.TaskForge.EventProcessor.csproj
        dotnet restore --verbosity minimal tests/IntegratonTests.TaskForge.EventProcessor/IntegratonTests.TaskForge.EventProcessor.csproj

    - name: Build EventProcessor
      run: dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal
      working-directory: src/TaskForge.EventProcessor

    - name: Build EventProcessor Test Projects
      run: |
        dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal tests/Tests.TaskForge.EventProcessor/Tests.TaskForge.EventProcessor.csproj
        dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal tests/IntegratonTests.TaskForge.EventProcessor/IntegratonTests.TaskForge.EventProcessor.csproj

    - name: Verify EventProcessor Build Success on PR
      if: github.event_name == 'pull_request'
      run: echo "✅ EventProcessor Build completed successfully!"

    - name: Copy coverlet.runsettings to test projects
      run: |
        cp tests/coverlet.runsettings tests/Tests.TaskForge.EventProcessor/coverlet.runsettings
        cp tests/coverlet.runsettings tests/IntegratonTests.TaskForge.EventProcessor/coverlet.runsettings

    - name: Run EventProcessor Unit Tests
      run: |
        dotnet test \
          --configuration ${{ env.BUILD_CONFIGURATION }} \
          --no-build \
          --nologo \
          --collect:"XPlat Code Coverage" \
          --settings coverlet.runsettings \
          --logger "trx;LogFileName=eventprocessor-unit-tests.trx" \
          --logger "console;verbosity=normal" \
          --blame \
          /p:CollectCoverage=true \
          /p:CoverletOutput=./TestResults/ \
          /p:CoverletOutputFormat=lcov \
          Tests.TaskForge.EventProcessor.csproj
      working-directory: tests/Tests.TaskForge.EventProcessor

    - name: Run EventProcessor Integration Tests
      run: |
        dotnet test \
          --configuration ${{ env.BUILD_CONFIGURATION }} \
          --no-build \
          --nologo \
          --collect:"XPlat Code Coverage" \
          --settings coverlet.runsettings \
          --logger "trx;LogFileName=eventprocessor-integration-tests.trx" \
          --logger "console;verbosity=normal" \
          --blame \
          /p:CollectCoverage=true \
          /p:CoverletOutput=./TestResults/ \
          /p:CoverletOutputFormat=lcov \
          /p:MergeWith=./TestResults/coverage.info \
          IntegratonTests.TaskForge.EventProcessor.csproj
      working-directory: tests/IntegratonTests.TaskForge.EventProcessor

    - name: Publish Test Results
      uses: EnricoMi/publish-unit-test-result-action@v2
      if: always()
      with:
        files: '**/TestResults/**/*.trx'
        check_name: 'EventProcessor Test Results'
        fail_on: 'errors'

    - name: Upload Code Coverage
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: eventprocessor-coverage
        path: '**/TestResults/**/coverage.cobertura.xml'
        retention-days: 7

    - name: Generate LCOV Coverage Report for Coveralls
      if: always()
      run: |
        # Install dependencies
        sudo apt-get update && sudo apt-get install -y lcov || true
        python3 -m pip install --upgrade pip --quiet || true
        python3 -m pip install pycobertura --quiet || true
        
        mkdir -p coverage-lcov
        
        for coverage_file in $(find . -name "coverage.cobertura.xml" -path "*/TestResults/*" 2>/dev/null); do
          if [ -f "$coverage_file" ]; then
            filename=$(basename "$coverage_file" .xml | tr '/' '_' | tr ' ' '_')
            echo "Converting: $coverage_file to coverage-lcov/${filename}.info"
            pycobertura convert --format lcov "$coverage_file" "coverage-lcov/${filename}.info" || true
          fi
        done
        
        # Merge all LCOV files into one
        if [ -d coverage-lcov ] && [ "$(ls -A coverage-lcov/*.info 2>/dev/null)" ]; then
          if command -v lcov &> /dev/null; then
            lcov -a coverage-lcov/*.info -o coverage-lcov/merged.info || true
          else
            cat coverage-lcov/*.info > coverage-lcov/merged.info || true
          fi
        fi
      continue-on-error: true

    - name: Upload LCOV Coverage for Coveralls
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: eventprocessor-coverage-lcov
        path: 'coverage-lcov/*.info'
        retention-days: 7
        if-no-files-found: ignore

  build-and-test-messageconsumer:
    name: 'Build and Test MessageConsumer'
    needs: build-common-projects
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET SDK ${{ env.DOTNET_VERSION }}
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Restore MessageConsumer and Tests
      run: |
        dotnet restore --verbosity minimal src/TaskForge.MessageConsumer/TaskForge.MessageConsumer.csproj
        dotnet restore --verbosity minimal tests/Tests.TaskForge.MessageConsumer/Tests.TaskForge.MessageConsumer.csproj
        dotnet restore --verbosity minimal tests/IntegratonTests.TaskForge.MessageConsumer/IntegratonTests.TaskForge.MessageConsumer.csproj

    - name: Build MessageConsumer
      run: dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal
      working-directory: src/TaskForge.MessageConsumer

    - name: Build MessageConsumer Test Projects
      run: |
        dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal tests/Tests.TaskForge.MessageConsumer/Tests.TaskForge.MessageConsumer.csproj
        dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal tests/IntegratonTests.TaskForge.MessageConsumer/IntegratonTests.TaskForge.MessageConsumer.csproj

    - name: Verify MessageConsumer Build Success on PR
      if: github.event_name == 'pull_request'
      run: echo "✅ MessageConsumer Build completed successfully!"

    - name: Copy coverlet.runsettings to test projects
      run: |
        cp tests/coverlet.runsettings tests/Tests.TaskForge.MessageConsumer/coverlet.runsettings
        cp tests/coverlet.runsettings tests/IntegratonTests.TaskForge.MessageConsumer/coverlet.runsettings

    - name: Run MessageConsumer Unit Tests
      run: |
        dotnet test \
          --configuration ${{ env.BUILD_CONFIGURATION }} \
          --no-build \
          --nologo \
          --collect:"XPlat Code Coverage" \
          --settings coverlet.runsettings \
          --logger "trx;LogFileName=messageconsumer-unit-tests.trx" \
          --logger "console;verbosity=normal" \
          --blame \
          /p:CollectCoverage=true \
          /p:CoverletOutput=./TestResults/ \
          /p:CoverletOutputFormat=lcov \
          Tests.TaskForge.MessageConsumer.csproj
      working-directory: tests/Tests.TaskForge.MessageConsumer

    - name: Run MessageConsumer Integration Tests
      run: |
        dotnet test \
          --configuration ${{ env.BUILD_CONFIGURATION }} \
          --no-build \
          --nologo \
          --collect:"XPlat Code Coverage" \
          --settings coverlet.runsettings \
          --logger "trx;LogFileName=messageconsumer-integration-tests.trx" \
          --logger "console;verbosity=normal" \
          --blame \
          /p:CollectCoverage=true \
          /p:CoverletOutput=./TestResults/ \
          /p:CoverletOutputFormat=lcov \
          /p:MergeWith=./TestResults/coverage.info \
          IntegratonTests.TaskForge.MessageConsumer.csproj
      working-directory: tests/IntegratonTests.TaskForge.MessageConsumer

    - name: Publish Test Results
      uses: EnricoMi/publish-unit-test-result-action@v2
      if: always()
      with:
        files: '**/TestResults/**/*.trx'
        check_name: 'MessageConsumer Test Results'
        fail_on: 'errors'

    - name: Upload Code Coverage
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: messageconsumer-coverage
        path: '**/TestResults/**/coverage.cobertura.xml'
        retention-days: 7

    - name: Generate LCOV Coverage Report for Coveralls
      if: always()
      run: |
        # Install dependencies
        sudo apt-get update && sudo apt-get install -y lcov || true
        python3 -m pip install --upgrade pip --quiet || true
        python3 -m pip install pycobertura --quiet || true
        
        mkdir -p coverage-lcov
        
        for coverage_file in $(find . -name "coverage.cobertura.xml" -path "*/TestResults/*" 2>/dev/null); do
          if [ -f "$coverage_file" ]; then
            filename=$(basename "$coverage_file" .xml | tr '/' '_' | tr ' ' '_')
            echo "Converting: $coverage_file to coverage-lcov/${filename}.info"
            pycobertura convert --format lcov "$coverage_file" "coverage-lcov/${filename}.info" || true
          fi
        done
        
        # Merge all LCOV files into one
        if [ -d coverage-lcov ] && [ "$(ls -A coverage-lcov/*.info 2>/dev/null)" ]; then
          if command -v lcov &> /dev/null; then
            lcov -a coverage-lcov/*.info -o coverage-lcov/merged.info || true
          else
            cat coverage-lcov/*.info > coverage-lcov/merged.info || true
          fi
        fi
      continue-on-error: true

    - name: Upload LCOV Coverage for Coveralls
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: messageconsumer-coverage-lcov
        path: 'coverage-lcov/*.info'
        retention-days: 7
        if-no-files-found: ignore

  run-common-tests:
    name: 'Run Common Tests (Application, Domain, Persistence)'
    needs: build-common-projects
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET SDK ${{ env.DOTNET_VERSION }}
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Restore Common Test Projects
      run: |
        dotnet restore --verbosity minimal tests/Tests.TaskForge.Application/Tests.TaskForge.Application.csproj
        dotnet restore --verbosity minimal tests/Tests.TaskForge.Domain/Tests.TaskForge.Domain.csproj
        dotnet restore --verbosity minimal tests/Tests.TaskForge.Persistence/Tests.TaskForge.Persistence.csproj
        dotnet restore --verbosity minimal tests/IntegratonTests.TaskForge.Application/IntegratonTests.TaskForge.Application.csproj
        dotnet restore --verbosity minimal tests/IntegratonTests.TaskForge.Persistence/IntegratonTests.TaskForge.Persistence.csproj

    - name: Build Common Test Projects
      run: |
        dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal tests/Tests.TaskForge.Application/Tests.TaskForge.Application.csproj
        dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal tests/Tests.TaskForge.Domain/Tests.TaskForge.Domain.csproj
        dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal tests/Tests.TaskForge.Persistence/Tests.TaskForge.Persistence.csproj
        dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal tests/IntegratonTests.TaskForge.Application/IntegratonTests.TaskForge.Application.csproj
        dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal tests/IntegratonTests.TaskForge.Persistence/IntegratonTests.TaskForge.Persistence.csproj

    - name: Copy coverlet.runsettings to test projects
      run: |
        cp tests/coverlet.runsettings tests/Tests.TaskForge.Application/coverlet.runsettings
        cp tests/coverlet.runsettings tests/Tests.TaskForge.Domain/coverlet.runsettings
        cp tests/coverlet.runsettings tests/Tests.TaskForge.Persistence/coverlet.runsettings
        cp tests/coverlet.runsettings tests/IntegratonTests.TaskForge.Application/coverlet.runsettings
        cp tests/coverlet.runsettings tests/IntegratonTests.TaskForge.Persistence/coverlet.runsettings

    - name: Run Application Unit Tests
      run: |
        dotnet test \
          --configuration ${{ env.BUILD_CONFIGURATION }} \
          --no-build \
          --nologo \
          --collect:"XPlat Code Coverage" \
          --settings coverlet.runsettings \
          --logger "trx;LogFileName=application-unit-tests.trx" \
          --logger "console;verbosity=normal" \
          --blame \
          /p:CollectCoverage=true \
          /p:CoverletOutput=./TestResults/ \
          /p:CoverletOutputFormat=lcov \
          Tests.TaskForge.Application.csproj
      working-directory: tests/Tests.TaskForge.Application

    - name: Run Domain Unit Tests
      run: |
        dotnet test \
          --configuration ${{ env.BUILD_CONFIGURATION }} \
          --no-build \
          --nologo \
          --collect:"XPlat Code Coverage" \
          --settings coverlet.runsettings \
          --logger "trx;LogFileName=domain-unit-tests.trx" \
          --logger "console;verbosity=normal" \
          --blame \
          /p:CollectCoverage=true \
          /p:CoverletOutput=./TestResults/ \
          /p:CoverletOutputFormat=lcov \
          /p:MergeWith=./TestResults/coverage.info \
          Tests.TaskForge.Domain.csproj
      working-directory: tests/Tests.TaskForge.Domain

    - name: Run Persistence Unit Tests
      run: |
        dotnet test \
          --configuration ${{ env.BUILD_CONFIGURATION }} \
          --no-build \
          --nologo \
          --collect:"XPlat Code Coverage" \
          --settings coverlet.runsettings \
          --logger "trx;LogFileName=persistence-unit-tests.trx" \
          --logger "console;verbosity=normal" \
          --blame \
          /p:CollectCoverage=true \
          /p:CoverletOutput=./TestResults/ \
          /p:CoverletOutputFormat=lcov \
          /p:MergeWith=./TestResults/coverage.info \
          Tests.TaskForge.Persistence.csproj
      working-directory: tests/Tests.TaskForge.Persistence

    - name: Run Application Integration Tests
      run: |
        dotnet test \
          --configuration ${{ env.BUILD_CONFIGURATION }} \
          --no-build \
          --nologo \
          --collect:"XPlat Code Coverage" \
          --settings coverlet.runsettings \
          --logger "trx;LogFileName=application-integration-tests.trx" \
          --logger "console;verbosity=normal" \
          --blame \
          /p:CollectCoverage=true \
          /p:CoverletOutput=./TestResults/ \
          /p:CoverletOutputFormat=lcov \
          /p:MergeWith=./TestResults/coverage.info \
          IntegratonTests.TaskForge.Application.csproj
      working-directory: tests/IntegratonTests.TaskForge.Application

    - name: Run Persistence Integration Tests
      run: |
        dotnet test \
          --configuration ${{ env.BUILD_CONFIGURATION }} \
          --no-build \
          --nologo \
          --collect:"XPlat Code Coverage" \
          --settings coverlet.runsettings \
          --logger "trx;LogFileName=persistence-integration-tests.trx" \
          --logger "console;verbosity=normal" \
          --blame \
          /p:CollectCoverage=true \
          /p:CoverletOutput=./TestResults/ \
          /p:CoverletOutputFormat=lcov \
          /p:MergeWith=./TestResults/coverage.info \
          IntegratonTests.TaskForge.Persistence.csproj
      working-directory: tests/IntegratonTests.TaskForge.Persistence

    - name: Publish Test Results
      uses: EnricoMi/publish-unit-test-result-action@v2
      if: always()
      with:
        files: '**/TestResults/**/*.trx'
        check_name: 'Common Tests Results'
        fail_on: 'errors'

    - name: Upload Code Coverage
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: common-coverage
        path: '**/TestResults/**/coverage.cobertura.xml'
        retention-days: 7

    - name: Generate LCOV Coverage Report for Coveralls
      if: always()
      run: |
        # Install dependencies
        sudo apt-get update && sudo apt-get install -y lcov || true
        python3 -m pip install --upgrade pip --quiet || true
        python3 -m pip install pycobertura --quiet || true
        
        mkdir -p coverage-lcov
        
        for coverage_file in $(find . -name "coverage.cobertura.xml" -path "*/TestResults/*" 2>/dev/null); do
          if [ -f "$coverage_file" ]; then
            filename=$(basename "$coverage_file" .xml | tr '/' '_' | tr ' ' '_')
            echo "Converting: $coverage_file to coverage-lcov/${filename}.info"
            pycobertura convert --format lcov "$coverage_file" "coverage-lcov/${filename}.info" || true
          fi
        done
        
        # Merge all LCOV files into one
        if [ -d coverage-lcov ] && [ "$(ls -A coverage-lcov/*.info 2>/dev/null)" ]; then
          if command -v lcov &> /dev/null; then
            lcov -a coverage-lcov/*.info -o coverage-lcov/merged.info || true
          else
            cat coverage-lcov/*.info > coverage-lcov/merged.info || true
          fi
        fi
      continue-on-error: true

    - name: Upload LCOV Coverage for Coveralls
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: common-coverage-lcov
        path: 'coverage-lcov/*.info'
        retention-days: 7
        if-no-files-found: ignore

  check-code-coverage:
    name: 'Check Code Coverage Threshold'
    needs:
      - build-and-test-api
      - build-and-test-eventprocessor
      - build-and-test-messageconsumer
      - run-common-tests
    runs-on: ubuntu-latest
    if: success()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download all coverage artifacts
      uses: actions/download-artifact@v4
      with:
        path: coverage-artifacts

    - name: Install dependencies for coverage check
      run: |
        sudo apt-get update
        sudo apt-get install -y bc xmlstarlet

    - name: Check Code Coverage Threshold
      shell: bash
      run: |
        echo "================================================"
        echo "Code Coverage Check (Per Service)"
        echo "================================================"
        
        # Find all coverage files
        coverage_files=$(find coverage-artifacts -name "coverage.cobertura.xml" -type f 2>/dev/null || true)
        
        if [ -z "$coverage_files" ]; then
          echo "⚠️ No coverage files found. Tests may not have generated coverage data."
          echo "This could happen if tests failed or coverage collection is disabled."
          echo "Continuing without coverage validation..."
          exit 0
        fi
        
        echo "Found coverage files"
        echo ""
        
        # Initialize coverage totals
        api_lines=0
        api_covered=0
        eventprocessor_lines=0
        eventprocessor_covered=0
        messageconsumer_lines=0
        messageconsumer_covered=0
        common_lines=0
        common_covered=0
        
        # Process each coverage file
        while IFS= read -r file; do
          if [ -z "$file" ] || [ ! -f "$file" ]; then
            continue
          fi
          
          file_lower=$(echo "$file" | tr '[:upper:]' '[:lower:]')
          
          # Extract coverage data using xmlstarlet
          lines_valid=$(xmlstarlet sel -t -v "//coverage/@lines-valid" "$file" 2>/dev/null || echo "0")
          lines_covered=$(xmlstarlet sel -t -v "//coverage/@lines-covered" "$file" 2>/dev/null || echo "0")
          
          if [ -z "$lines_valid" ] || [ "$lines_valid" = "0" ]; then
            # Fallback: use grep
            lines_valid=$(grep -oP 'lines-valid="\K[0-9]+' "$file" 2>/dev/null | head -1 || echo "0")
            lines_covered=$(grep -oP 'lines-covered="\K[0-9]+' "$file" 2>/dev/null | head -1 || echo "0")
          fi
          
          if [ "$lines_valid" -gt 0 ] 2>/dev/null; then
            if [[ "$file_lower" == *"api"* ]] && [[ "$file_lower" != *"eventprocessor"* ]] && [[ "$file_lower" != *"messageconsumer"* ]]; then
              api_lines=$((api_lines + lines_valid))
              api_covered=$((api_covered + lines_covered))
              echo "API: $(basename "$file") - $lines_covered/$lines_valid"
            elif [[ "$file_lower" == *"eventprocessor"* ]]; then
              eventprocessor_lines=$((eventprocessor_lines + lines_valid))
              eventprocessor_covered=$((eventprocessor_covered + lines_covered))
              echo "EventProcessor: $(basename "$file") - $lines_covered/$lines_valid"
            elif [[ "$file_lower" == *"messageconsumer"* ]]; then
              messageconsumer_lines=$((messageconsumer_lines + lines_valid))
              messageconsumer_covered=$((messageconsumer_covered + lines_covered))
              echo "MessageConsumer: $(basename "$file") - $lines_covered/$lines_valid"
            else
              common_lines=$((common_lines + lines_valid))
              common_covered=$((common_covered + lines_covered))
              echo "Common: $(basename "$file") - $lines_covered/$lines_valid"
            fi
          fi
        done <<< "$coverage_files"
        
        # Calculate percentages and check thresholds
        all_passed=true
        
        # Check API coverage
        if [ "$api_lines" -gt 0 ]; then
          api_percent=$(awk "BEGIN {printf \"%.2f\", ($api_covered/$api_lines)*100}")
          echo ""
          echo "----------------------------------------"
          echo "Service: API"
          echo "Total Coverage: ${api_percent}% ($api_covered/$api_lines lines)"
          echo "Required: ${{ env.MIN_COVERAGE_API }}%"
          
          if (( $(echo "$api_percent < ${{ env.MIN_COVERAGE_API }}" | bc -l) )); then
            all_passed=false
            echo ""
            echo "❌ FAILED: Coverage ${api_percent}% is below required ${{ env.MIN_COVERAGE_API }}%"
          else
            echo ""
            echo "✅ PASSED: Coverage meets requirement"
          fi
        fi
        
        # Check EventProcessor coverage (skip if threshold is 0)
        if [ "${{ env.MIN_COVERAGE_EVENTPROCESSOR }}" -gt 0 ]; then
          if [ "$eventprocessor_lines" -gt 0 ]; then
            eventprocessor_percent=$(awk "BEGIN {printf \"%.2f\", ($eventprocessor_covered/$eventprocessor_lines)*100}")
            echo ""
            echo "----------------------------------------"
            echo "Service: EventProcessor"
            echo "Total Coverage: ${eventprocessor_percent}% ($eventprocessor_covered/$eventprocessor_lines lines)"
            echo "Required: ${{ env.MIN_COVERAGE_EVENTPROCESSOR }}%"
            
            if (( $(echo "$eventprocessor_percent < ${{ env.MIN_COVERAGE_EVENTPROCESSOR }}" | bc -l) )); then
              all_passed=false
              echo ""
              echo "❌ FAILED: Coverage ${eventprocessor_percent}% is below required ${{ env.MIN_COVERAGE_EVENTPROCESSOR }}%"
            else
              echo ""
              echo "✅ PASSED: Coverage meets requirement"
            fi
          fi
        else
          echo ""
          echo "ℹ️ No coverage requirement for EventProcessor service (threshold: 0%)"
        fi
        
        # Check MessageConsumer coverage (skip if threshold is 0)
        if [ "${{ env.MIN_COVERAGE_MESSAGECONSUMER }}" -gt 0 ]; then
          if [ "$messageconsumer_lines" -gt 0 ]; then
            messageconsumer_percent=$(awk "BEGIN {printf \"%.2f\", ($messageconsumer_covered/$messageconsumer_lines)*100}")
            echo ""
            echo "----------------------------------------"
            echo "Service: MessageConsumer"
            echo "Total Coverage: ${messageconsumer_percent}% ($messageconsumer_covered/$messageconsumer_lines lines)"
            echo "Required: ${{ env.MIN_COVERAGE_MESSAGECONSUMER }}%"
            
            if (( $(echo "$messageconsumer_percent < ${{ env.MIN_COVERAGE_MESSAGECONSUMER }}" | bc -l) )); then
              all_passed=false
              echo ""
              echo "❌ FAILED: Coverage ${messageconsumer_percent}% is below required ${{ env.MIN_COVERAGE_MESSAGECONSUMER }}%"
            else
              echo ""
              echo "✅ PASSED: Coverage meets requirement"
            fi
          fi
        else
          echo ""
          echo "ℹ️ No coverage requirement for MessageConsumer service (threshold: 0%)"
        fi
        
        # Check Common coverage
        if [ "$common_lines" -gt 0 ]; then
          common_percent=$(awk "BEGIN {printf \"%.2f\", ($common_covered/$common_lines)*100}")
          echo ""
          echo "----------------------------------------"
          echo "Service: Common"
          echo "Total Coverage: ${common_percent}% ($common_covered/$common_lines lines)"
          echo "Required: ${{ env.MIN_COVERAGE_COMMON }}%"
          
          if (( $(echo "$common_percent < ${{ env.MIN_COVERAGE_COMMON }}" | bc -l) )); then
            all_passed=false
            echo ""
            echo "❌ FAILED: Coverage ${common_percent}% is below required ${{ env.MIN_COVERAGE_COMMON }}%"
          else
            echo ""
            echo "✅ PASSED: Coverage meets requirement"
          fi
        fi
        
        echo ""
        echo "================================================"
        
        if [ "$all_passed" = false ]; then
          echo ""
          echo "❌ CODE COVERAGE CHECK FAILED!"
          echo "One or more services do not meet the minimum coverage requirement."
          echo "Please add more unit tests to improve code coverage."
          echo ""
          exit 1
        else
          echo ""
          echo "✅ CODE COVERAGE CHECK PASSED"
          echo "All services meet their minimum coverage requirements."
          echo ""
        fi
        
        echo "================================================"

    - name: Publish Code Coverage to Codecov
      uses: codecov/codecov-action@v4
      if: always()
      with:
        files: coverage-artifacts/**/coverage.cobertura.xml
        flags: unittests
        name: codecov-umbrella
        fail_ci_if_error: false

    - name: Download all LCOV coverage artifacts
      uses: actions/download-artifact@v4
      if: always()
      with:
        path: coverage-lcov-artifacts
        pattern: '*-coverage-lcov'
        merge-multiple: true

    - name: Download Cobertura coverage artifacts (fallback)
      uses: actions/download-artifact@v4
      if: always()
      with:
        path: coverage-artifacts
        pattern: '*-coverage'
        merge-multiple: true

    - name: Merge LCOV Coverage Reports
      if: always()
      run: |
        # Install lcov for merging
        sudo apt-get update && sudo apt-get install -y lcov || true
        
        mkdir -p merged-coverage
        
        echo "========================================="
        echo "Collecting LCOV files from artifacts"
        echo "========================================="
        echo "Current directory: $(pwd)"
        
        # Find all LCOV files in downloaded artifacts
        lcov_files=$(find coverage-lcov-artifacts -name "coverage.info" -type f 2>/dev/null || true)
        lcov_count=$(echo "$lcov_files" | wc -l | tr -d ' ' || echo "0")
        
        echo "Found LCOV files: $lcov_count"
        
        if [ "$lcov_count" -gt 0 ] && [ -n "$lcov_files" ]; then
          echo "LCOV files found:"
          echo "$lcov_files" | head -10
          echo ""
          
          # Copy all LCOV files to merged-coverage directory
          for lcov_file in $lcov_files; do
            if [ -f "$lcov_file" ]; then
              cp "$lcov_file" merged-coverage/ 2>/dev/null || true
            fi
          done
          
          # Find all copied files
          merged_files=$(find merged-coverage -name "*.info" -type f 2>/dev/null || true)
          merged_count=$(echo "$merged_files" | wc -l | tr -d ' ' || echo "0")
          
          echo "Files ready for merging: $merged_count"
          
          if [ "$merged_count" -gt 0 ] && [ -n "$merged_files" ]; then
            echo ""
            echo "Merging LCOV files..."
            
            # Merge using lcov
            if command -v lcov &> /dev/null; then
              lcov -a $(echo "$merged_files" | tr '\n' ' ') -o merged-coverage/merged.info 2>&1 || {
                echo "lcov merge failed, trying alternative method..."
                # Fallback: use first file as base and merge others
                first_file=$(echo "$merged_files" | head -1)
                cp "$first_file" merged-coverage/merged.info 2>/dev/null || true
                for file in $(echo "$merged_files" | tail -n +2); do
                  if [ -f "$file" ]; then
                    lcov -a merged-coverage/merged.info -a "$file" -o merged-coverage/merged.tmp 2>/dev/null && \
                    mv merged-coverage/merged.tmp merged-coverage/merged.info || true
                  fi
                done
              }
            else
              echo "lcov not available, using first file as merged..."
              first_file=$(echo "$merged_files" | head -1)
              cp "$first_file" merged-coverage/merged.info 2>/dev/null || true
            fi
            
            # Verify merged file
            if [ -f merged-coverage/merged.info ]; then
              file_size=$(stat -c%s merged-coverage/merged.info 2>/dev/null || echo "0")
              file_lines=$(wc -l < merged-coverage/merged.info || echo 0)
              echo ""
              echo "✅ Merged file created: $file_lines lines, $file_size bytes"
              
              if [ "$file_lines" -gt 10 ]; then
                echo "✅ Merged file has content"
              else
                echo "⚠️ WARNING: Merged file is too small!"
              fi
            else
              echo "❌ ERROR: merged.info file was not created!"
            fi
          else
            echo "❌ No LCOV files found for merging!"
          fi
        else
          echo "❌ No LCOV files found in artifacts!"
          echo "Directory contents:"
          find coverage-lcov-artifacts -type f -name "*.info" 2>/dev/null | head -20 || echo "No .info files found"
        fi
        
        echo ""
        echo "========================================="
        
        # Verify final file exists
        if [ -f merged-coverage/merged.info ]; then
          file_lines=$(wc -l < merged-coverage/merged.info || echo 0)
          echo "✅ merged-coverage/merged.info exists ($file_lines lines)"
          echo "Full path: $(pwd)/merged-coverage/merged.info"
        else
          echo "❌ ERROR: merged-coverage/merged.info does not exist!"
          echo "Creating minimal file as fallback..."
          mkdir -p merged-coverage
          echo "TN:" > merged-coverage/merged.info
          echo "end_of_record" >> merged-coverage/merged.info
        fi
      continue-on-error: false

    - name: Verify Coverage File Before Upload
      if: always()
      run: |
        echo "Current working directory: $(pwd)"
        echo "GitHub workspace: ${{ github.workspace }}"
        echo "Checking for coverage files..."
        
        if [ -f merged-coverage/merged.info ]; then
          echo "✅ File exists: merged-coverage/merged.info"
          echo "Absolute path: $(realpath merged-coverage/merged.info 2>/dev/null || echo "$(pwd)/merged-coverage/merged.info")"
          echo "File size: $(stat -f%z merged-coverage/merged.info 2>/dev/null || stat -c%s merged-coverage/merged.info 2>/dev/null || echo 'unknown') bytes"
          echo "File lines: $(wc -l < merged-coverage/merged.info || echo 0)"
          echo "First 10 lines:"
          head -10 merged-coverage/merged.info || true
        else
          echo "❌ File does not exist: merged-coverage/merged.info"
          echo "Listing merged-coverage directory:"
          ls -la merged-coverage/ 2>/dev/null || echo "Directory does not exist"
          echo "Creating minimal file..."
          mkdir -p merged-coverage
          echo "TN:" > merged-coverage/merged.info
          echo "end_of_record" >> merged-coverage/merged.info
          echo "✅ Created minimal coverage file"
        fi
        
        # Store absolute path for next step
        COVERAGE_FILE=$(realpath merged-coverage/merged.info 2>/dev/null || echo "$(pwd)/merged-coverage/merged.info")
        echo "COVERAGE_FILE=$COVERAGE_FILE" >> $GITHUB_ENV
        echo "Coverage file path: $COVERAGE_FILE"

    - name: Publish Code Coverage to Coveralls
      if: always()
      uses: coverallsapp/github-action@v2
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        path-to-lcov: merged-coverage/merged.info
        base-path: ${{ github.workspace }}
        fail-on-error: false
        parallel: false
      env:
        COVERALLS_REPO_TOKEN: ${{ secrets.COVERALLS_REPO_TOKEN }}
        COVERALLS_SERVICE_NAME: github-actions
        COVERALLS_GIT_BRANCH: ${{ github.ref_name }}
        COVERALLS_GIT_COMMIT: ${{ github.sha }}
      continue-on-error: true

  build-docker-images:
    name: 'Build Docker Images'
    needs:
      - build-and-test-api
      - build-and-test-eventprocessor
      - build-and-test-messageconsumer
      - run-common-tests
      - check-code-coverage
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master' && github.event_name == 'push'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build API Docker Image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: src/TaskForge.API/Dockerfile
        push: false
        tags: taskforge-api:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build EventProcessor Docker Image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: src/TaskForge.EventProcessor/Dockerfile
        push: false
        tags: taskforge-eventprocessor:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build MessageConsumer Docker Image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: src/TaskForge.MessageConsumer/Dockerfile
        push: false
        tags: taskforge-messageconsumer:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build Client Docker Image
      uses: docker/build-push-action@v5
      with:
        context: ./src/client-app
        file: ./src/client-app/Dockerfile
        push: false
        tags: taskforge-client:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max
