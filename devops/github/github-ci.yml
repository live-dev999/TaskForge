name: Build and Test

on:
  push:
    branches:
    - master
    - dev
      - feature/*
    paths-ignore:
      - 'README.md'
      - 'docs/**'
      - 'design/**'
  pull_request:
    branches:
    - master
    - dev
      - feature/*

permissions:
  contents: read
  checks: write
  pull-requests: write

env:
  SOLUTION: '**/TaskForge.sln'
  BUILD_CONFIGURATION: 'Release'
  DOTNET_VERSION: '8.0.411'
  # Code coverage thresholds
  MIN_COVERAGE_API: 5
  MIN_COVERAGE_EVENTPROCESSOR: 0
  MIN_COVERAGE_MESSAGECONSUMER: 0
  MIN_COVERAGE_COMMON: 40

jobs:
  build-common-projects:
    name: 'Build Common Projects (Domain, Application, Persistence)'
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET SDK ${{ env.DOTNET_VERSION }}
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Restore NuGet packages
      run: dotnet restore --verbosity minimal
      working-directory: src/TaskForge.Domain

    - name: Restore Application packages
      run: dotnet restore --verbosity minimal
      working-directory: src/TaskForge.Application

    - name: Restore Persistence packages
      run: dotnet restore --verbosity minimal
      working-directory: src/TaskForge.Persistence

    - name: Restore StartupTasks packages
      run: dotnet restore --verbosity minimal
      working-directory: src/TaskForge.StartupTasks

    - name: Build Common Projects
      run: |
        dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal
      working-directory: src/TaskForge.Domain

    - name: Build Application
      run: dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal
      working-directory: src/TaskForge.Application

    - name: Build Persistence
      run: dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal
      working-directory: src/TaskForge.Persistence

    - name: Build StartupTasks
      run: dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal
      working-directory: src/TaskForge.StartupTasks

  build-and-test-api:
    name: 'Build and Test API'
    needs: build-common-projects
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET SDK ${{ env.DOTNET_VERSION }}
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Restore API and Tests
      run: |
        dotnet restore --verbosity minimal src/TaskForge.API/TaskForge.API.csproj
        dotnet restore --verbosity minimal tests/Tests.TaskForge.API/Tests.TaskForge.API.csproj
        dotnet restore --verbosity minimal tests/IntegratonTests.TaskForge.API/IntegratonTests.TaskForge.API.csproj

    - name: Build API
      run: dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal
      working-directory: src/TaskForge.API

    - name: Build API Test Projects
      run: |
        dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal tests/Tests.TaskForge.API/Tests.TaskForge.API.csproj
        dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal tests/IntegratonTests.TaskForge.API/IntegratonTests.TaskForge.API.csproj

    - name: Verify API Build Success on PR
      if: github.event_name == 'pull_request'
      run: echo "✅ API Build completed successfully!"

    - name: Create TestResults directory
      run: mkdir -p TestResults

    - name: Run API Unit Tests
      run: |
        dotnet test \
          --configuration ${{ env.BUILD_CONFIGURATION }} \
          --no-build \
          --verbosity normal \
          --logger "trx;LogFileName=api-unit-tests.trx" \
          /p:CollectCoverage=true \
          /p:CoverletOutput=../../TestResults/coverage.info \
          /p:CoverletOutputFormat=lcov \
          Tests.TaskForge.API.csproj
      working-directory: tests/Tests.TaskForge.API

    - name: Run API Integration Tests
      run: |
        dotnet test \
          --configuration ${{ env.BUILD_CONFIGURATION }} \
          --no-build \
          --verbosity normal \
          --logger "trx;LogFileName=api-integration-tests.trx" \
          /p:MergeWith=../../TestResults/coverage.info \
          /p:CollectCoverage=true \
          /p:CoverletOutput=../../TestResults/coverage.info \
          /p:CoverletOutputFormat=lcov \
          IntegratonTests.TaskForge.API.csproj
      working-directory: tests/IntegratonTests.TaskForge.API

    - name: Publish Test Results
      uses: EnricoMi/publish-unit-test-result-action@v2
      if: always()
      with:
        files: '**/TestResults/**/*.trx'
        check_name: 'API Test Results'
        fail_on: 'errors'

    - name: Upload Code Coverage (Cobertura)
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: api-coverage
        path: '**/TestResults/**/coverage.cobertura.xml'
        retention-days: 7
        if-no-files-found: ignore

    - name: Verify LCOV file exists before Coveralls
      if: always()
      run: |
        echo "Current directory: $(pwd)"
        echo "Looking for TestResults/coverage.info..."
        if [ -f TestResults/coverage.info ]; then
          echo "✅ File found: TestResults/coverage.info"
          echo "File size: $(stat -c%s TestResults/coverage.info 2>/dev/null || stat -f%z TestResults/coverage.info 2>/dev/null || echo 'unknown') bytes"
          echo "File lines: $(wc -l < TestResults/coverage.info || echo 0)"
          echo "First 5 lines:"
          head -5 TestResults/coverage.info || true
          echo ""
          echo "Sample SF (source file) entries:"
          grep "^SF:" TestResults/coverage.info | head -3 || echo "No SF: entries found"
        else
          echo "❌ ERROR: TestResults/coverage.info not found!"
          echo "Listing TestResults directory:"
          ls -la TestResults/ 2>/dev/null || echo "TestResults directory does not exist"
          echo ""
          echo "Searching for any .info files:"
          find . -name "*.info" -type f 2>/dev/null | head -10 || echo "No .info files found"
          exit 1
        fi

    - name: Publish API coverage report to Coveralls
      if: always()
      uses: coverallsapp/github-action@v2
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        path-to-lcov: TestResults/coverage.info
        fail-on-error: false
        parallel: false
      env:
        COVERALLS_REPO_TOKEN: ${{ secrets.COVERALLS_REPO_TOKEN }}
        COVERALLS_SERVICE_NAME: github-actions
        COVERALLS_GIT_BRANCH: ${{ github.ref_name }}
        COVERALLS_GIT_COMMIT: ${{ github.sha }}
      continue-on-error: true

  build-and-test-eventprocessor:
    name: 'Build and Test EventProcessor'
    needs: build-common-projects
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET SDK ${{ env.DOTNET_VERSION }}
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Restore EventProcessor and Tests
      run: |
        dotnet restore --verbosity minimal src/TaskForge.EventProcessor/TaskForge.EventProcessor.csproj
        dotnet restore --verbosity minimal tests/Tests.TaskForge.EventProcessor/Tests.TaskForge.EventProcessor.csproj
        dotnet restore --verbosity minimal tests/IntegratonTests.TaskForge.EventProcessor/IntegratonTests.TaskForge.EventProcessor.csproj

    - name: Build EventProcessor
      run: dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal
      working-directory: src/TaskForge.EventProcessor

    - name: Build EventProcessor Test Projects
      run: |
        dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal tests/Tests.TaskForge.EventProcessor/Tests.TaskForge.EventProcessor.csproj
        dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal tests/IntegratonTests.TaskForge.EventProcessor/IntegratonTests.TaskForge.EventProcessor.csproj

    - name: Verify EventProcessor Build Success on PR
      if: github.event_name == 'pull_request'
      run: echo "✅ EventProcessor Build completed successfully!"

    - name: Create TestResults directory
      run: mkdir -p TestResults

    - name: Run EventProcessor Unit Tests
      run: |
        dotnet test \
          --configuration ${{ env.BUILD_CONFIGURATION }} \
          --no-build \
          --verbosity normal \
          --logger "trx;LogFileName=eventprocessor-unit-tests.trx" \
          /p:CollectCoverage=true \
          /p:CoverletOutput=../../TestResults/coverage.info \
          /p:CoverletOutputFormat=lcov \
          Tests.TaskForge.EventProcessor.csproj
      working-directory: tests/Tests.TaskForge.EventProcessor

    - name: Run EventProcessor Integration Tests
      run: |
        dotnet test \
          --configuration ${{ env.BUILD_CONFIGURATION }} \
          --no-build \
          --verbosity normal \
          --logger "trx;LogFileName=eventprocessor-integration-tests.trx" \
          /p:MergeWith=../../TestResults/coverage.info \
          /p:CollectCoverage=true \
          /p:CoverletOutput=../../TestResults/coverage.info \
          /p:CoverletOutputFormat=lcov \
          IntegratonTests.TaskForge.EventProcessor.csproj
      working-directory: tests/IntegratonTests.TaskForge.EventProcessor

    - name: Publish Test Results
      uses: EnricoMi/publish-unit-test-result-action@v2
      if: always()
      with:
        files: '**/TestResults/**/*.trx'
        check_name: 'EventProcessor Test Results'
        fail_on: 'errors'

    - name: Upload Code Coverage (Cobertura)
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: eventprocessor-coverage
        path: '**/TestResults/**/coverage.cobertura.xml'
        retention-days: 7
        if-no-files-found: ignore

    - name: Verify LCOV file exists before Coveralls
      if: always()
      run: |
        if [ -f TestResults/coverage.info ]; then
          echo "✅ File found: TestResults/coverage.info ($(wc -l < TestResults/coverage.info || echo 0) lines)"
        else
          echo "❌ ERROR: TestResults/coverage.info not found!"
          find . -name "*.info" -type f 2>/dev/null | head -10 || echo "No .info files found"
          exit 1
        fi

    - name: Publish EventProcessor coverage report to Coveralls
      if: always()
      uses: coverallsapp/github-action@v2
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        path-to-lcov: TestResults/coverage.info
        fail-on-error: false
        parallel: false
      env:
        COVERALLS_REPO_TOKEN: ${{ secrets.COVERALLS_REPO_TOKEN }}
        COVERALLS_SERVICE_NAME: github-actions
        COVERALLS_GIT_BRANCH: ${{ github.ref_name }}
        COVERALLS_GIT_COMMIT: ${{ github.sha }}
      continue-on-error: true

  build-and-test-messageconsumer:
    name: 'Build and Test MessageConsumer'
    needs: build-common-projects
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET SDK ${{ env.DOTNET_VERSION }}
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Restore MessageConsumer and Tests
      run: |
        dotnet restore --verbosity minimal src/TaskForge.MessageConsumer/TaskForge.MessageConsumer.csproj
        dotnet restore --verbosity minimal tests/Tests.TaskForge.MessageConsumer/Tests.TaskForge.MessageConsumer.csproj
        dotnet restore --verbosity minimal tests/IntegratonTests.TaskForge.MessageConsumer/IntegratonTests.TaskForge.MessageConsumer.csproj

    - name: Build MessageConsumer
      run: dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal
      working-directory: src/TaskForge.MessageConsumer

    - name: Build MessageConsumer Test Projects
      run: |
        dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal tests/Tests.TaskForge.MessageConsumer/Tests.TaskForge.MessageConsumer.csproj
        dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal tests/IntegratonTests.TaskForge.MessageConsumer/IntegratonTests.TaskForge.MessageConsumer.csproj

    - name: Verify MessageConsumer Build Success on PR
      if: github.event_name == 'pull_request'
      run: echo "✅ MessageConsumer Build completed successfully!"

    - name: Create TestResults directory
      run: mkdir -p TestResults

    - name: Run MessageConsumer Unit Tests
      run: |
        dotnet test \
          --configuration ${{ env.BUILD_CONFIGURATION }} \
          --no-build \
          --verbosity normal \
          --logger "trx;LogFileName=messageconsumer-unit-tests.trx" \
          /p:CollectCoverage=true \
          /p:CoverletOutput=../../TestResults/coverage.info \
          /p:CoverletOutputFormat=lcov \
          Tests.TaskForge.MessageConsumer.csproj
      working-directory: tests/Tests.TaskForge.MessageConsumer

    - name: Run MessageConsumer Integration Tests
      run: |
        dotnet test \
          --configuration ${{ env.BUILD_CONFIGURATION }} \
          --no-build \
          --verbosity normal \
          --logger "trx;LogFileName=messageconsumer-integration-tests.trx" \
          /p:MergeWith=../../TestResults/coverage.info \
          /p:CollectCoverage=true \
          /p:CoverletOutput=../../TestResults/coverage.info \
          /p:CoverletOutputFormat=lcov \
          IntegratonTests.TaskForge.MessageConsumer.csproj
      working-directory: tests/IntegratonTests.TaskForge.MessageConsumer

    - name: Publish Test Results
      uses: EnricoMi/publish-unit-test-result-action@v2
      if: always()
      with:
        files: '**/TestResults/**/*.trx'
        check_name: 'MessageConsumer Test Results'
        fail_on: 'errors'

    - name: Upload Code Coverage (Cobertura)
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: messageconsumer-coverage
        path: '**/TestResults/**/coverage.cobertura.xml'
        retention-days: 7
        if-no-files-found: ignore

    - name: Verify LCOV file exists before Coveralls
      if: always()
      run: |
        if [ -f TestResults/coverage.info ]; then
          echo "✅ File found: TestResults/coverage.info ($(wc -l < TestResults/coverage.info || echo 0) lines)"
        else
          echo "❌ ERROR: TestResults/coverage.info not found!"
          find . -name "*.info" -type f 2>/dev/null | head -10 || echo "No .info files found"
          exit 1
        fi

    - name: Publish MessageConsumer coverage report to Coveralls
      if: always()
      uses: coverallsapp/github-action@v2
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        path-to-lcov: TestResults/coverage.info
        fail-on-error: false
        parallel: false
      env:
        COVERALLS_REPO_TOKEN: ${{ secrets.COVERALLS_REPO_TOKEN }}
        COVERALLS_SERVICE_NAME: github-actions
        COVERALLS_GIT_BRANCH: ${{ github.ref_name }}
        COVERALLS_GIT_COMMIT: ${{ github.sha }}
      continue-on-error: true

  run-common-tests:
    name: 'Run Common Tests (Application, Domain, Persistence)'
    needs: build-common-projects
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET SDK ${{ env.DOTNET_VERSION }}
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Restore Common Test Projects
      run: |
        dotnet restore --verbosity minimal tests/Tests.TaskForge.Application/Tests.TaskForge.Application.csproj
        dotnet restore --verbosity minimal tests/Tests.TaskForge.Domain/Tests.TaskForge.Domain.csproj
        dotnet restore --verbosity minimal tests/Tests.TaskForge.Persistence/Tests.TaskForge.Persistence.csproj
        dotnet restore --verbosity minimal tests/IntegratonTests.TaskForge.Application/IntegratonTests.TaskForge.Application.csproj
        dotnet restore --verbosity minimal tests/IntegratonTests.TaskForge.Persistence/IntegratonTests.TaskForge.Persistence.csproj

    - name: Build Common Test Projects
      run: |
        dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal tests/Tests.TaskForge.Application/Tests.TaskForge.Application.csproj
        dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal tests/Tests.TaskForge.Domain/Tests.TaskForge.Domain.csproj
        dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal tests/Tests.TaskForge.Persistence/Tests.TaskForge.Persistence.csproj
        dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal tests/IntegratonTests.TaskForge.Application/IntegratonTests.TaskForge.Application.csproj
        dotnet build --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore --verbosity minimal tests/IntegratonTests.TaskForge.Persistence/IntegratonTests.TaskForge.Persistence.csproj

    - name: Create TestResults directory
      run: mkdir -p TestResults

    - name: Run Application Unit Tests
      run: |
        dotnet test \
          --configuration ${{ env.BUILD_CONFIGURATION }} \
          --no-build \
          --verbosity normal \
          --logger "trx;LogFileName=application-unit-tests.trx" \
          /p:CollectCoverage=true \
          /p:CoverletOutput=../../TestResults/coverage.info \
          /p:CoverletOutputFormat=lcov \
          Tests.TaskForge.Application.csproj
      working-directory: tests/Tests.TaskForge.Application

    - name: Run Domain Unit Tests
      run: |
        dotnet test \
          --configuration ${{ env.BUILD_CONFIGURATION }} \
          --no-build \
          --verbosity normal \
          --logger "trx;LogFileName=domain-unit-tests.trx" \
          /p:MergeWith=../../TestResults/coverage.info \
          /p:CollectCoverage=true \
          /p:CoverletOutput=../../TestResults/coverage.info \
          /p:CoverletOutputFormat=lcov \
          Tests.TaskForge.Domain.csproj
      working-directory: tests/Tests.TaskForge.Domain

    - name: Run Persistence Unit Tests
      run: |
        dotnet test \
          --configuration ${{ env.BUILD_CONFIGURATION }} \
          --no-build \
          --verbosity normal \
          --logger "trx;LogFileName=persistence-unit-tests.trx" \
          /p:MergeWith=../../TestResults/coverage.info \
          /p:CollectCoverage=true \
          /p:CoverletOutput=../../TestResults/coverage.info \
          /p:CoverletOutputFormat=lcov \
          Tests.TaskForge.Persistence.csproj
      working-directory: tests/Tests.TaskForge.Persistence

    - name: Run Application Integration Tests
      run: |
        dotnet test \
          --configuration ${{ env.BUILD_CONFIGURATION }} \
          --no-build \
          --verbosity normal \
          --logger "trx;LogFileName=application-integration-tests.trx" \
          /p:MergeWith=../../TestResults/coverage.info \
          /p:CollectCoverage=true \
          /p:CoverletOutput=../../TestResults/coverage.info \
          /p:CoverletOutputFormat=lcov \
          IntegratonTests.TaskForge.Application.csproj
      working-directory: tests/IntegratonTests.TaskForge.Application

    - name: Run Persistence Integration Tests
      run: |
        dotnet test \
          --configuration ${{ env.BUILD_CONFIGURATION }} \
          --no-build \
          --verbosity normal \
          --logger "trx;LogFileName=persistence-integration-tests.trx" \
          /p:MergeWith=../../TestResults/coverage.info \
          /p:CollectCoverage=true \
          /p:CoverletOutput=../../TestResults/coverage.info \
          /p:CoverletOutputFormat=lcov \
          IntegratonTests.TaskForge.Persistence.csproj
      working-directory: tests/IntegratonTests.TaskForge.Persistence

    - name: Publish Test Results
      uses: EnricoMi/publish-unit-test-result-action@v2
      if: always()
      with:
        files: '**/TestResults/**/*.trx'
        check_name: 'Common Tests Results'
        fail_on: 'errors'

    - name: Upload Code Coverage (Cobertura)
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: common-coverage
        path: '**/TestResults/**/coverage.cobertura.xml'
        retention-days: 7
        if-no-files-found: ignore

    - name: Verify LCOV file exists before Coveralls
      if: always()
      run: |
        if [ -f TestResults/coverage.info ]; then
          echo "✅ File found: TestResults/coverage.info ($(wc -l < TestResults/coverage.info || echo 0) lines)"
        else
          echo "❌ ERROR: TestResults/coverage.info not found!"
          find . -name "*.info" -type f 2>/dev/null | head -10 || echo "No .info files found"
          exit 1
        fi

    - name: Publish Common Tests coverage report to Coveralls
      if: always()
      uses: coverallsapp/github-action@v2
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        path-to-lcov: TestResults/coverage.info
        fail-on-error: false
        parallel: false
      env:
        COVERALLS_REPO_TOKEN: ${{ secrets.COVERALLS_REPO_TOKEN }}
        COVERALLS_SERVICE_NAME: github-actions
        COVERALLS_GIT_BRANCH: ${{ github.ref_name }}
        COVERALLS_GIT_COMMIT: ${{ github.sha }}
      continue-on-error: true

  check-code-coverage:
    name: 'Check Code Coverage Threshold'
    needs:
      - build-and-test-api
      - build-and-test-eventprocessor
      - build-and-test-messageconsumer
      - run-common-tests
    runs-on: ubuntu-latest
    if: success()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download all coverage artifacts
      uses: actions/download-artifact@v4
      with:
        path: coverage-artifacts

    - name: Install dependencies for coverage check
      run: |
        sudo apt-get update
        sudo apt-get install -y bc xmlstarlet

    - name: Check Code Coverage Threshold
      shell: bash
      run: |
        echo "================================================"
        echo "Code Coverage Check (Per Service)"
        echo "================================================"
        
        # Find all coverage files
        coverage_files=$(find coverage-artifacts -name "coverage.cobertura.xml" -type f 2>/dev/null || true)
        
        if [ -z "$coverage_files" ]; then
          echo "⚠️ No coverage files found. Tests may not have generated coverage data."
          echo "This could happen if tests failed or coverage collection is disabled."
          echo "Continuing without coverage validation..."
          exit 0
        fi
        
        echo "Found coverage files"
        echo ""
        
        # Initialize coverage totals
        api_lines=0
        api_covered=0
        eventprocessor_lines=0
        eventprocessor_covered=0
        messageconsumer_lines=0
        messageconsumer_covered=0
        common_lines=0
        common_covered=0
        
        # Process each coverage file
        while IFS= read -r file; do
          if [ -z "$file" ] || [ ! -f "$file" ]; then
            continue
          fi
          
          file_lower=$(echo "$file" | tr '[:upper:]' '[:lower:]')
          
          # Extract coverage data using xmlstarlet
          lines_valid=$(xmlstarlet sel -t -v "//coverage/@lines-valid" "$file" 2>/dev/null || echo "0")
          lines_covered=$(xmlstarlet sel -t -v "//coverage/@lines-covered" "$file" 2>/dev/null || echo "0")
          
          if [ -z "$lines_valid" ] || [ "$lines_valid" = "0" ]; then
            # Fallback: use grep
            lines_valid=$(grep -oP 'lines-valid="\K[0-9]+' "$file" 2>/dev/null | head -1 || echo "0")
            lines_covered=$(grep -oP 'lines-covered="\K[0-9]+' "$file" 2>/dev/null | head -1 || echo "0")
          fi
          
          if [ "$lines_valid" -gt 0 ] 2>/dev/null; then
            if [[ "$file_lower" == *"api"* ]] && [[ "$file_lower" != *"eventprocessor"* ]] && [[ "$file_lower" != *"messageconsumer"* ]]; then
              api_lines=$((api_lines + lines_valid))
              api_covered=$((api_covered + lines_covered))
              echo "API: $(basename "$file") - $lines_covered/$lines_valid"
            elif [[ "$file_lower" == *"eventprocessor"* ]]; then
              eventprocessor_lines=$((eventprocessor_lines + lines_valid))
              eventprocessor_covered=$((eventprocessor_covered + lines_covered))
              echo "EventProcessor: $(basename "$file") - $lines_covered/$lines_valid"
            elif [[ "$file_lower" == *"messageconsumer"* ]]; then
              messageconsumer_lines=$((messageconsumer_lines + lines_valid))
              messageconsumer_covered=$((messageconsumer_covered + lines_covered))
              echo "MessageConsumer: $(basename "$file") - $lines_covered/$lines_valid"
            else
              common_lines=$((common_lines + lines_valid))
              common_covered=$((common_covered + lines_covered))
              echo "Common: $(basename "$file") - $lines_covered/$lines_valid"
            fi
          fi
        done <<< "$coverage_files"
        
        # Calculate percentages and check thresholds
        all_passed=true
        
        # Check API coverage
        if [ "$api_lines" -gt 0 ]; then
          api_percent=$(awk "BEGIN {printf \"%.2f\", ($api_covered/$api_lines)*100}")
          echo ""
          echo "----------------------------------------"
          echo "Service: API"
          echo "Total Coverage: ${api_percent}% ($api_covered/$api_lines lines)"
          echo "Required: ${{ env.MIN_COVERAGE_API }}%"
          
          if (( $(echo "$api_percent < ${{ env.MIN_COVERAGE_API }}" | bc -l) )); then
            all_passed=false
            echo ""
            echo "❌ FAILED: Coverage ${api_percent}% is below required ${{ env.MIN_COVERAGE_API }}%"
          else
            echo ""
            echo "✅ PASSED: Coverage meets requirement"
          fi
        fi
        
        # Check EventProcessor coverage (skip if threshold is 0)
        if [ "${{ env.MIN_COVERAGE_EVENTPROCESSOR }}" -gt 0 ]; then
          if [ "$eventprocessor_lines" -gt 0 ]; then
            eventprocessor_percent=$(awk "BEGIN {printf \"%.2f\", ($eventprocessor_covered/$eventprocessor_lines)*100}")
            echo ""
            echo "----------------------------------------"
            echo "Service: EventProcessor"
            echo "Total Coverage: ${eventprocessor_percent}% ($eventprocessor_covered/$eventprocessor_lines lines)"
            echo "Required: ${{ env.MIN_COVERAGE_EVENTPROCESSOR }}%"
            
            if (( $(echo "$eventprocessor_percent < ${{ env.MIN_COVERAGE_EVENTPROCESSOR }}" | bc -l) )); then
              all_passed=false
              echo ""
              echo "❌ FAILED: Coverage ${eventprocessor_percent}% is below required ${{ env.MIN_COVERAGE_EVENTPROCESSOR }}%"
            else
              echo ""
              echo "✅ PASSED: Coverage meets requirement"
            fi
          fi
        else
          echo ""
          echo "ℹ️ No coverage requirement for EventProcessor service (threshold: 0%)"
        fi
        
        # Check MessageConsumer coverage (skip if threshold is 0)
        if [ "${{ env.MIN_COVERAGE_MESSAGECONSUMER }}" -gt 0 ]; then
          if [ "$messageconsumer_lines" -gt 0 ]; then
            messageconsumer_percent=$(awk "BEGIN {printf \"%.2f\", ($messageconsumer_covered/$messageconsumer_lines)*100}")
            echo ""
            echo "----------------------------------------"
            echo "Service: MessageConsumer"
            echo "Total Coverage: ${messageconsumer_percent}% ($messageconsumer_covered/$messageconsumer_lines lines)"
            echo "Required: ${{ env.MIN_COVERAGE_MESSAGECONSUMER }}%"
            
            if (( $(echo "$messageconsumer_percent < ${{ env.MIN_COVERAGE_MESSAGECONSUMER }}" | bc -l) )); then
              all_passed=false
              echo ""
              echo "❌ FAILED: Coverage ${messageconsumer_percent}% is below required ${{ env.MIN_COVERAGE_MESSAGECONSUMER }}%"
            else
              echo ""
              echo "✅ PASSED: Coverage meets requirement"
            fi
          fi
        else
          echo ""
          echo "ℹ️ No coverage requirement for MessageConsumer service (threshold: 0%)"
        fi
        
        # Check Common coverage
        if [ "$common_lines" -gt 0 ]; then
          common_percent=$(awk "BEGIN {printf \"%.2f\", ($common_covered/$common_lines)*100}")
          echo ""
          echo "----------------------------------------"
          echo "Service: Common"
          echo "Total Coverage: ${common_percent}% ($common_covered/$common_lines lines)"
          echo "Required: ${{ env.MIN_COVERAGE_COMMON }}%"
          
          if (( $(echo "$common_percent < ${{ env.MIN_COVERAGE_COMMON }}" | bc -l) )); then
            all_passed=false
            echo ""
            echo "❌ FAILED: Coverage ${common_percent}% is below required ${{ env.MIN_COVERAGE_COMMON }}%"
          else
            echo ""
            echo "✅ PASSED: Coverage meets requirement"
          fi
        fi
        
        echo ""
        echo "================================================"
        
        if [ "$all_passed" = false ]; then
          echo ""
          echo "❌ CODE COVERAGE CHECK FAILED!"
          echo "One or more services do not meet the minimum coverage requirement."
          echo "Please add more unit tests to improve code coverage."
          echo ""
          exit 1
        else
          echo ""
          echo "✅ CODE COVERAGE CHECK PASSED"
          echo "All services meet their minimum coverage requirements."
          echo ""
        fi
        
        echo "================================================"

    - name: Publish Code Coverage to Codecov
      uses: codecov/codecov-action@v4
      if: always()
      with:
        files: coverage-artifacts/**/coverage.cobertura.xml
        flags: unittests
        name: codecov-umbrella
        fail_ci_if_error: false

    - name: Download Cobertura coverage artifacts (fallback)
      uses: actions/download-artifact@v4
      if: always()
      with:
        path: coverage-artifacts
        pattern: '*-coverage'
        merge-multiple: true

    # LCOV coverage is now sent directly to Coveralls by each service job
    # No need to merge LCOV files here anymore

  build-docker-images:
    name: 'Build Docker Images'
    needs:
      - build-and-test-api
      - build-and-test-eventprocessor
      - build-and-test-messageconsumer
      - run-common-tests
      - check-code-coverage
    runs-on: ubuntu-latest
    if: false  # Disabled: Docker build and publish stages disabled for all CI
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build API Docker Image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: src/TaskForge.API/Dockerfile
        push: false
        tags: taskforge-api:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build EventProcessor Docker Image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: src/TaskForge.EventProcessor/Dockerfile
        push: false
        tags: taskforge-eventprocessor:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build MessageConsumer Docker Image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: src/TaskForge.MessageConsumer/Dockerfile
        push: false
        tags: taskforge-messageconsumer:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build Client Docker Image
      uses: docker/build-push-action@v5
      with:
        context: ./src/client-app
        file: ./src/client-app/Dockerfile
        push: false
        tags: taskforge-client:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max
